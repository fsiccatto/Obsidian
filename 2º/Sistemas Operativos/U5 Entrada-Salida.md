## Principios del Hardware de E/S
### Dispositivos de E/S
Se dividen en dos categorías: 
- **Dispositivos de bloque**:  almacena información en bloques de tamaño fijo, cada uno con su propia dirección. Todas las transferencias se realizan en unidades de uno o más bloques completos. Es posible leer o escribir cada bloque de manera independiente de los demás. <mark style="background: #D2B3FFA6;">HDD, CD-ROMs, USBs</mark>.
- **Dispositivos de caracter**: envía o acepta un flujo de caracteres, sin importar la estructura del bloque. No es direccionable y no tiene ninguna operación de búsqueda. <mark style="background: #D2B3FFA6;">Impresoras, interfaces de red, ratones, teclados</mark>.
### Controladores de dispositivos
Las unidades de E/S consisten en un componente mecánico (dispositivo en sí) y un componente electrónico (controlador de dispositivo, es *HARDWARE*).
El trabajo del controlador es convertir el flujo de bits serial en un bloque de bytes y realizar cualquier corrección de errores necesaria. Luego copia a la RAM los datos después de haber hecho las verificaciones correspondientes.
### E/S por asignación de memoria
¿Cómo se comunica la CPU con los registros de control y los *buffers* de datos de los dispositivos?
Existen dos alternativas:
1. Primer método, a cada registro de control se le asigna un número de puerto de E/S, un entero de 8 o 16 bits. El conjunto de todos los puertos de E/S forma el **espacio de puertos de E/S** y está protegido de manera que los programas de usuario ordinarios no puedan utilizarlo (solo el SO puede). Figura (a).
2. Segundo método, es asignar todos los registros de control al espacio de memoria, como se muestra en la figura (b). A cada registro de control se le asigna una dirección de memoria única a la cual no hay memoria asignada. Este sistema se conoce como **E/S con asignación de memoria** (*mapped-memory*).
3. En la figura (c) se muestra un esquema híbrido, con *buffers* de datos de E/S por asignación de memoria y puertos de E/S separados para los registros de control.
![[imgs/e-s por asignacion de memoria.png]]
> [!important] ¿Cómo funcionan estos esquemas?
> En todos los casos, cuando la CPU desea leer una palabra ya sea de la memoria o de un puerto de E/S, coloca la dirección que necesita en las líneas de dirección del bus y después impone una señal READ en una línea de control del bus. Se utiliza una segunda línea de señal para indicar si se necesita espacio de E/S o de memoria. Si es espacio de memoria, ésta responde a la petición. Si es espacio de E/S, el dispositivo de E/S responde a la petición. Si sólo hay espacio de memoria \[como en la figura 5-2(b)], todos los módulos de memoria y todos los dispositivos de E/S comparan las líneas de dirección con el rango de direcciones a las que dan servicio. Si la dirección está en su rango, responde a la petición. Como ninguna dirección se asigna tanto a la memoria como a un dispositivo de E/S, no hay ambigüedad ni conflicto.

La E/S por asignación de memoria tiene sus desventajas👎
1. El hardware debe ser capaz de deshabilitar la caché en forma selectiva (por página). Esto agrega una complejidad adicional al hardware y al sistema operativo.
2. Si la computadora tiene un solo bus, como en la figura 5-3(a), es simple hacer que todos analicen cada dirección. Sin embargo, las computadoras modernas tienen un bus dedicado a alta velocidad. El problema es que los dispositivos no tienen forma de ver las direcciones de memoria a medida que recorren el bus de memoria, por lo que no tienen manera de responderles.
![[imgs/arquitectura bus.png]]
### Acceso directo a memoria (DMA)
El controlador de DMA tiene acceso al bus del sistema de manera independiente de la CPU.
#### Sin DMA
| Sin DMA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| el controlador de disco lee el bloque (uno o más sectores) de la unidad en forma serial, bit por bit, hasta que se coloca todo el bloque completo en el búfer interno del controlador. Después calcula la suma de comprobación para verificar que no hayan ocurrido errores de lectura. Después, el controlador produce una interrupción. Cuando el sistema  operativo empieza a ejecutarse, puede leer el bloque de disco del búfer del controlador, un byte o una palabra a la vez, mediante la ejecución de un ciclo en el que cada iteración se lee un byte o palabra de un registro de dispositivo controlador y se almacena en la memoria principal. |
#### Con DMA
| Con DMA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| La CPU programa el controlador de DMA, para lo cual establece sus registros de manera que sepa qué debe transferir y a dónde (paso1). También emite un comando al controlador de disco para indicarle que debe leer datos del disco en su búfer interno y verificar la suma de comprobación. Cuando hay datos válidos en el búfer del controlador de disco, puede empezar el DMA.<br>El controlador de DMA inicia la transferencia enviando una petición de lectura al controlador de disco mediante el bus (paso 2). Esta petición de lectura se ve como cualquier otra petición de lectura, por lo que el controlador de disco no sabe ni le importa si vino de la CPU o de un controlador de DMA. Por lo general, la dirección de memoria en la que se va a escribir está en las líneas de dirección del bus, por lo que cuando el controlador de disco obtiene la siguiente palabra de subúfer interno, sabe dónde escribir. La escritura en memoria es otro ciclo de bus estándar (paso 3). Cuando se completa la escritura, el controlador de disco envía una señal de reconocimiento al controlador de DMA, también a través del bus (paso 4). El controlador de DMA incrementa a continuación la dirección de memoria a utilizar y disminuye la cuenta de bytes. Si la cuenta de bytes es<br>aún mayor que 0, se repiten los pasos del 2 al 4 hasta que la cuenta llega a 0. En ese momento, el controlador de DMA interrumpe la CPU para hacerle saber que la transferencia está completa. Cuando el sistema operativo se inicia, no tiene que copiar el bloque de disco en la memoria; ya se encuentra ahí. |
![[imgs/operacion con DMA.png]]
En resumen el DMA: 
- Tiene acceso al bus,
- Libera CPU de la tarea de I/O. Interrumpe solo una vez (cuando termina),
- Modo Palabra o Bloque:
	- Por palabra cuando DMA se apropia del Bus la CPU debe esperar $\to$ Robo de ciclos
	- Por Bloque adquiere el bus, transfiere y libera el bus $\to$ Modo ráfaga
- Transfiere directamente a la memoria principal
### Interrupciones
Cuando un dispositivo de E/S ha terminado el trabajo que se le asignó, produce una interrupción (suponiendo que el sistema operativo haya habilitado las interrupciones). Para ello, impone una señal en una línea de bus que se le haya asignado. Esta señal es detectada por el chip controlador de interrupciones en la tarjeta principal, que después decide lo que debe hacer.
![[imgs/interrupciones.png]]
- Si no hay otras interrupciones pendientes, el controlador de interrupciones procesa la interrupción de inmediato.
- Si hay otra en progreso, o si otro dispositivo ha realizado una petición simultánea en una línea de petición de interrupción de mayor prioridad en el bus, el dispositivo sólo se ignora por el momento.
#### Interrupciones precisas e imprecisas
Una interrupción que deja al equipo en un estado bien definido se conoce como **interrupción precisa**. Tiene 4 propiedades:
1. El contador del programa (PC) se guarda en un lugar conocido.
2. Todas las instrucciones antes de la instrucción a la que apunta el PC se han ejecutado por completo.
3. Ninguna instrucción más allá de la instrucción a la que apunta el PC se ha ejecutado.
4. Se conoce el estado de ejecución de la instrucción a la que apunta el PC.
Una interrupción que no cumple con estos requerimientos se conoce como **interrupción imprecisa**.
![[imgs/interrupciones precisas e impresisas.png]]
> [!caution] ¿Para que sirve una interrupción imprecisa?
## Fundamentos del Software de E/S
### Objetivos del software de E/S
**Independencia de dispositivos**: escribir programas que puedan acceder a cualquier dispositivo de E/S sin tener que especificar el dispositivo por adelantado. El SO debe resolver el uso de distintos dispositivos, que necesitan distintas ordenes para manejarlos.
**Denominación uniforme**: El nombre de un archivo o dispositivo simplemente debe ser una cadena o un entero sin depender del dispositivo de ninguna forma.
**Manejo de errores**: los errores se deben manejar lo más cerca del hardware que sea posible, pero si no es posible el SW debe detectarlo o indicar a la aplicación (disco lleno, file not found)
Transferencias **síncronas** (de bloqueo) vs **asíncronas** (controladas por interrupciones). La mayoría de las operaciones de E/S son asíncronas: se inicia la transferencia y el CPU hace algo más hasta que llega la interrupción. Depende del sistema operativo hacer que las operaciones que en realidad son controladas por interrupciones parezcan de bloqueo para los programas de usuario.
**Uso del *buffer***: a veces los datos que provienen de dispositviso no se pueden lamacenar directamente en su destino final, por lo que los datos se deben colocar en un buffer de salida por adelantado para desacoplar la velocidad a la que se llena el buffer, de la velocidad a la que se vacía, de manera que se eviten sub-desbordamientos de búfer.
Dispositivos compartidos y los dispositivos dedicados:
- Los discos son compartidos ya que pueden ser utilizados por varios usuarios a la vez.
- Las cintas son dedicados a un solo usuario hasta que éste termine.
### E/S Programada
La CPU hace todo el trabajo.
> [!example] Ejemplo
> Un usuario que desea imprimir la cadena de ocho caracteres “ABCDEFGH” en la impresora. Primero ensambla la cadena en un búfer en espacio de usuario, como se muestra en la figura 5-7(a).
> Después el proceso de usuario adquiere la impresora para escribir, haciendo una llamada al sistema para abrirla. Si la impresora está actualmente siendo utilizada por otro proceso, esta llamada fallará y devolverá un código de error o se bloqueará hasta que la impresora esté disponible, dependiendo del sistema operativo y los parámetros de la llamada. Una vez que obtiene la impresora, el proceso de usuario hace una llamada al sistema para indicar al sistema operativo que imprima la cadena en la impresora
> ![[imgs/imprimir una cadena.png]]

