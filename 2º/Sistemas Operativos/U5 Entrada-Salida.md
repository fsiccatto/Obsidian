## Principios del Hardware de E/S
### Dispositivos de E/S
Se dividen en dos categor√≠as: 
- **Dispositivos de bloque**:  almacena informaci√≥n en bloques de tama√±o fijo, cada uno con su propia direcci√≥n. Todas las transferencias se realizan en unidades de uno o m√°s bloques completos. Es posible leer o escribir cada bloque de manera independiente de los dem√°s. <mark style="background: #D2B3FFA6;">HDD, CD-ROMs, USBs</mark>.
- **Dispositivos de caracter**: env√≠a o acepta un flujo de caracteres, sin importar la estructura del bloque. No es direccionable y no tiene ninguna operaci√≥n de b√∫squeda. <mark style="background: #D2B3FFA6;">Impresoras, interfaces de red, ratones, teclados</mark>.
### Controladores de dispositivos
Las unidades de E/S consisten en un componente mec√°nico (dispositivo en s√≠) y un componente electr√≥nico (controlador de dispositivo, es *HARDWARE*).
El trabajo del controlador es convertir el flujo de bits serial en un bloque de bytes y realizar cualquier correcci√≥n de errores necesaria. Luego copia a la RAM los datos despu√©s de haber hecho las verificaciones correspondientes.
### E/S por asignaci√≥n de memoria
¬øC√≥mo se comunica la CPU con los registros de control y los *buffers* de datos de los dispositivos?
Existen dos alternativas:
1. Primer m√©todo, a cada registro de control se le asigna un n√∫mero de puerto de E/S, un entero de 8 o 16 bits. El conjunto de todos los puertos de E/S forma el **espacio de puertos de E/S** y est√° protegido de manera que los programas de usuario ordinarios no puedan utilizarlo (solo el SO puede). Figura (a).
2. Segundo m√©todo, es asignar todos los registros de control al espacio de memoria, como se muestra en la figura (b). A cada registro de control se le asigna una direcci√≥n de memoria √∫nica a la cual no hay memoria asignada. Este sistema se conoce como **E/S con asignaci√≥n de memoria** (*mapped-memory*).
3. En la figura (c) se muestra un esquema h√≠brido, con *buffers* de datos de E/S por asignaci√≥n de memoria y puertos de E/S separados para los registros de control.
![[imgs/e-s por asignacion de memoria.png]]
> [!important] ¬øC√≥mo funcionan estos esquemas?
> En todos los casos, cuando la CPU desea leer una palabra ya sea de la memoria o de un puerto de E/S, coloca la direcci√≥n que necesita en las l√≠neas de direcci√≥n del bus y despu√©s impone una se√±al READ en una l√≠nea de control del bus. Se utiliza una segunda l√≠nea de se√±al para indicar si se necesita espacio de E/S o de memoria. Si es espacio de memoria, √©sta responde a la petici√≥n. Si es espacio de E/S, el dispositivo de E/S responde a la petici√≥n. Si s√≥lo hay espacio de memoria \[como en la figura 5-2(b)], todos los m√≥dulos de memoria y todos los dispositivos de E/S comparan las l√≠neas de direcci√≥n con el rango de direcciones a las que dan servicio. Si la direcci√≥n est√° en su rango, responde a la petici√≥n. Como ninguna direcci√≥n se asigna tanto a la memoria como a un dispositivo de E/S, no hay ambig√ºedad ni conflicto.

La E/S por asignaci√≥n de memoria tiene sus desventajasüëé
1. El hardware debe ser capaz de deshabilitar la cach√© en forma selectiva (por p√°gina). Esto agrega una complejidad adicional al hardware y al sistema operativo.
2. Si la computadora tiene un solo bus, como en la figura 5-3(a), es simple hacer que todos analicen cada direcci√≥n. Sin embargo, las computadoras modernas tienen un bus dedicado a alta velocidad. El problema es que los dispositivos no tienen forma de ver las direcciones de memoria a medida que recorren el bus de memoria, por lo que no tienen manera de responderles.
![[imgs/arquitectura bus.png]]
### Acceso directo a memoria (DMA)
El controlador de DMA tiene acceso al bus del sistema de manera independiente de la CPU.
#### Sin DMA
| Sin DMA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| el controlador de disco lee el bloque (uno o m√°s sectores) de la unidad en forma serial, bit por bit, hasta que se coloca todo el bloque completo en el b√∫fer interno del controlador. Despu√©s calcula la suma de comprobaci√≥n para verificar que no hayan ocurrido errores de lectura. Despu√©s, el controlador produce una interrupci√≥n. Cuando el sistema  operativo empieza a ejecutarse, puede leer el bloque de disco del b√∫fer del controlador, un byte o una palabra a la vez, mediante la ejecuci√≥n de un ciclo en el que cada iteraci√≥n se lee un byte o palabra de un registro de dispositivo controlador y se almacena en la memoria principal. |
#### Con DMA
| Con DMA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| La CPU programa el controlador de DMA, para lo cual establece sus registros de manera que sepa qu√© debe transferir y a d√≥nde (paso1). Tambi√©n emite un comando al controlador de disco para indicarle que debe leer datos del disco en su b√∫fer interno y verificar la suma de comprobaci√≥n. Cuando hay datos v√°lidos en el b√∫fer del controlador de disco, puede empezar el DMA.<br>El controlador de DMA inicia la transferencia enviando una petici√≥n de lectura al controlador de disco mediante el bus (paso 2). Esta petici√≥n de lectura se ve como cualquier otra petici√≥n de lectura, por lo que el controlador de disco no sabe ni le importa si vino de la CPU o de un controlador de DMA. Por lo general, la direcci√≥n de memoria en la que se va a escribir est√° en las l√≠neas de direcci√≥n del bus, por lo que cuando el controlador de disco obtiene la siguiente palabra de sub√∫fer interno, sabe d√≥nde escribir. La escritura en memoria es otro ciclo de bus est√°ndar (paso 3). Cuando se completa la escritura, el controlador de disco env√≠a una se√±al de reconocimiento al controlador de DMA, tambi√©n a trav√©s del bus (paso 4). El controlador de DMA incrementa a continuaci√≥n la direcci√≥n de memoria a utilizar y disminuye la cuenta de bytes. Si la cuenta de bytes es<br>a√∫n mayor que 0, se repiten los pasos del 2 al 4 hasta que la cuenta llega a 0. En ese momento, el controlador de DMA interrumpe la CPU para hacerle saber que la transferencia est√° completa. Cuando el sistema operativo se inicia, no tiene que copiar el bloque de disco en la memoria; ya se encuentra ah√≠. |
![[imgs/operacion con DMA.png]]
En resumen el DMA: 
- Tiene acceso al bus,
- Libera CPU de la tarea de I/O. Interrumpe solo una vez (cuando termina),
- Modo Palabra o Bloque:
	- Por palabra cuando DMA se apropia del Bus la CPU debe esperar $\to$ Robo de ciclos
	- Por Bloque adquiere el bus, transfiere y libera el bus $\to$ Modo r√°faga
- Transfiere directamente a la memoria principal
### Interrupciones
Cuando un dispositivo de E/S ha terminado el trabajo que se le asign√≥, produce una interrupci√≥n (suponiendo que el sistema operativo haya habilitado las interrupciones). Para ello, impone una se√±al en una l√≠nea de bus que se le haya asignado. Esta se√±al es detectada por el chip controlador de interrupciones en la tarjeta principal, que despu√©s decide lo que debe hacer.
![[imgs/interrupciones.png]]
- Si no hay otras interrupciones pendientes, el controlador de interrupciones procesa la interrupci√≥n de inmediato.
- Si hay otra en progreso, o si otro dispositivo ha realizado una petici√≥n simult√°nea en una l√≠nea de petici√≥n de interrupci√≥n de mayor prioridad en el bus, el dispositivo s√≥lo se ignora por el momento.
#### Interrupciones precisas e imprecisas
Una interrupci√≥n que deja al equipo en un estado bien definido se conoce como **interrupci√≥n precisa**. Tiene 4 propiedades:
1. El contador del programa (PC) se guarda en un lugar conocido.
2. Todas las instrucciones antes de la instrucci√≥n a la que apunta el PC se han ejecutado por completo.
3. Ninguna instrucci√≥n m√°s all√° de la instrucci√≥n a la que apunta el PC se ha ejecutado.
4. Se conoce el estado de ejecuci√≥n de la instrucci√≥n a la que apunta el PC.
Una interrupci√≥n que no cumple con estos requerimientos se conoce como **interrupci√≥n imprecisa**.
![[imgs/interrupciones precisas e impresisas.png]]
> [!caution] ¬øPara que sirve una interrupci√≥n imprecisa?
## Fundamentos del Software de E/S
### Objetivos del software de E/S
**Independencia de dispositivos**: escribir programas que puedan acceder a cualquier dispositivo de E/S sin tener que especificar el dispositivo por adelantado. El SO debe resolver el uso de distintos dispositivos, que necesitan distintas ordenes para manejarlos.
**Denominaci√≥n uniforme**: El nombre de un archivo o dispositivo simplemente debe ser una cadena o un entero sin depender del dispositivo de ninguna forma.
**Manejo de errores**: los errores se deben manejar lo m√°s cerca del hardware que sea posible, pero si no es posible el SW debe detectarlo o indicar a la aplicaci√≥n (disco lleno, file not found)
Transferencias **s√≠ncronas** (de bloqueo) vs **as√≠ncronas** (controladas por interrupciones). La mayor√≠a de las operaciones de E/S son as√≠ncronas: se inicia la transferencia y el CPU hace algo m√°s hasta que llega la interrupci√≥n. Depende del sistema operativo hacer que las operaciones que en realidad son controladas por interrupciones parezcan de bloqueo para los programas de usuario.
**Uso del *buffer***: a veces los datos que provienen de dispositviso no se pueden lamacenar directamente en su destino final, por lo que los datos se deben colocar en un buffer de salida por adelantado para desacoplar la velocidad a la que se llena el buffer, de la velocidad a la que se vac√≠a, de manera que se eviten sub-desbordamientos de b√∫fer.
Dispositivos compartidos y los dispositivos dedicados:
- Los discos son compartidos ya que pueden ser utilizados por varios usuarios a la vez.
- Las cintas son dedicados a un solo usuario hasta que √©ste termine.
### E/S Programada
La CPU hace todo el trabajo.
> [!example] Ejemplo
> Un usuario que desea imprimir la cadena de ocho caracteres ‚ÄúABCDEFGH‚Äù en la impresora. Primero ensambla la cadena en un b√∫fer en espacio de usuario, como se muestra en la figura 5-7(a).
> Despu√©s el proceso de usuario adquiere la impresora para escribir, haciendo una llamada al sistema para abrirla. Si la impresora est√° actualmente siendo utilizada por otro proceso, esta llamada fallar√° y devolver√° un c√≥digo de error o se bloquear√° hasta que la impresora est√© disponible, dependiendo del sistema operativo y los par√°metros de la llamada. Una vez que obtiene la impresora, el proceso de usuario hace una llamada al sistema para indicar al sistema operativo que imprima la cadena en la impresora
> ![[imgs/imprimir una cadena.png]]

